name: Sync and Translate Qubic Docs

on:
  schedule:
    # Täglich um 02:00 UTC (außerhalb der Hauptnutzungszeiten)
    - cron: '0 2 * * *'
  workflow_dispatch:  # Manuelles Triggern möglich

env:
  UPSTREAM_REPO: qubic/docs
  UPSTREAM_BRANCH: main
  TRANSLATION_BRANCH: translation-sync
  DEEPSEEK_API_KEY: ${{ secrets.DEEPSEEK_API_KEY }}

jobs:
  sync-and-translate:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      # 1. Checkout des Forks
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      # 2. Git-Konfiguration
      - name: Configure Git
        run: |
          git config user.name "Qubic Translation Bot"
          git config user.email "translation-bot@qubic-network.de"

      # 3. Upstream Repository hinzufügen
      - name: Add upstream remote
        run: |
          git remote add upstream https://github.com/${{ env.UPSTREAM_REPO }}.git
          git fetch upstream

      # 4. Änderungen seit letztem Sync ermitteln
      - name: Detect changes
        id: changes
        run: |
          # Letzten Sync-Commit finden
          LAST_SYNC=$(git log --grep="Translation sync" --format="%H" -n 1 || echo "")
          
          if [ -z "$LAST_SYNC" ]; then
            # Erster Durchlauf - alle Dateien
            echo "changed_files=all" >> $GITHUB_OUTPUT
            echo "is_initial_sync=true" >> $GITHUB_OUTPUT
          else
            # Änderungen seit letztem Sync (nur overview Ordner)
            git diff --name-only $LAST_SYNC upstream/${{ env.UPSTREAM_BRANCH }} -- docs/overview/ > changed_files.txt
            
            if [ -s changed_files.txt ]; then
              echo "changed_files=changed_files.txt" >> $GITHUB_OUTPUT
              echo "files_changed=true" >> $GITHUB_OUTPUT
              echo "Changed files:"
              cat changed_files.txt
            else
              echo "files_changed=false" >> $GITHUB_OUTPUT
              echo "No changes detected"
            fi
          fi

      # 5. Node.js Setup
      - name: Setup Node.js
        if: steps.changes.outputs.files_changed == 'true' || steps.changes.outputs.is_initial_sync == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      # 6. Dependencies installieren
      - name: Install dependencies
        if: steps.changes.outputs.files_changed == 'true' || steps.changes.outputs.is_initial_sync == 'true'
        run: |
          npm init -y
          npm install axios glob

      # 7. Übersetzungsscript erstellen
      - name: Create translation script
        if: steps.changes.outputs.files_changed == 'true' || steps.changes.outputs.is_initial_sync == 'true'
        run: |
          cat > translate.js << 'EOF'
          const fs = require('fs');
          const path = require('path');
          const axios = require('axios');
          const glob = require('glob');

          const DEEPSEEK_API_URL = 'https://api.deepseek.com/v1/chat/completions';
          const DEEPSEEK_API_KEY = process.env.DEEPSEEK_API_KEY;

          // Übersetzungsprompt für technische Dokumentation
          const TRANSLATION_PROMPT = `Du bist ein professioneller Übersetzer für technische Blockchain-Dokumentation.
          Übersetze den folgenden Text ins Deutsche:
          
          Regeln:
          1. Behalte alle Markdown-Formatierungen bei (##, **, \`\`\`, etc.)
          2. Übersetze Code-Kommentare, aber NICHT Code-Blöcke
          3. Behalte technische Begriffe wie "quorum", "computor", "epoch" bei oder übersetze sie konsistent
          4. Behalte URLs und Dateipfade unverändert
          5. Behalte YAML-Frontmatter-Struktur bei
          6. Verwende professionelle, klare Sprache
          7. Achte auf korrekte deutsche Grammatik und Zeichensetzung
          
          Text zum Übersetzen:
          `;

          async function translateText(text) {
            try {
              const response = await axios.post(
                DEEPSEEK_API_URL,
                {
                  model: 'deepseek-chat',
                  messages: [
                    {
                      role: 'system',
                      content: 'Du bist ein Experte für technische Übersetzungen im Blockchain-Bereich.'
                    },
                    {
                      role: 'user',
                      content: TRANSLATION_PROMPT + text
                    }
                  ],
                  temperature: 0.3,
                  max_tokens: 4000
                },
                {
                  headers: {
                    'Authorization': `Bearer ${DEEPSEEK_API_KEY}`,
                    'Content-Type': 'application/json'
                  }
                }
              );

              return response.data.choices[0].message.content;
            } catch (error) {
              console.error('Translation error:', error.response?.data || error.message);
              throw error;
            }
          }

          // Eigene Frontmatter-Parsing Funktion
          function parseFrontmatter(content) {
            const match = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
            if (!match) return { frontmatter: {}, body: content };
            
            const frontmatterText = match[1];
            const body = match[2].trim();
            const frontmatter = {};
            
            frontmatterText.split('\n').forEach(line => {
              const colonIndex = line.indexOf(':');
              if (colonIndex > 0) {
                const key = line.substring(0, colonIndex).trim();
                let value = line.substring(colonIndex + 1).trim();
                // Entferne Anführungszeichen
                if ((value.startsWith('"') && value.endsWith('"')) || 
                    (value.startsWith("'") && value.endsWith("'"))) {
                  value = value.slice(1, -1);
                }
                // Parse numbers
                if (!isNaN(value) && value !== '') {
                  frontmatter[key] = parseInt(value);
                } else {
                  frontmatter[key] = value;
                }
              }
            });
            
            return { frontmatter, body };
          }

          // Funktion um Frontmatter als sauberes YAML zu formatieren
          function formatFrontmatter(obj) {
            const lines = [];
            for (const [key, value] of Object.entries(obj)) {
              if (typeof value === 'string') {
                // Immer einfache Anführungszeichen verwenden
                lines.push(`${key}: '${value}'`);
              } else {
                lines.push(`${key}: ${value}`);
              }
            }
            return lines.join('\n');
          }

          async function translateFile(inputPath, outputPath) {
            console.log(`Translating: ${inputPath}`);
            
            const content = fs.readFileSync(inputPath, 'utf-8');
            const { frontmatter, body } = parseFrontmatter(content);

            // Übersetze den Hauptinhalt
            const translatedBody = await translateText(body);

            // Frontmatter übersetzen
            const translatedFrontmatter = { ...frontmatter };
            if (frontmatter.title) {
              translatedFrontmatter.title = await translateText(frontmatter.title);
            }
            if (frontmatter.sidebar_label) {
              translatedFrontmatter.sidebar_label = await translateText(frontmatter.sidebar_label);
            }
            if (frontmatter.description) {
              translatedFrontmatter.description = await translateText(frontmatter.description);
            }

            // Zusammenbauen mit korrektem YAML-Format
            const yamlFrontmatter = formatFrontmatter(translatedFrontmatter);
            const output = `---\n${yamlFrontmatter}\n---\n\n${translatedBody}`;

            // Sicherstellen, dass das Ausgabeverzeichnis existiert
            fs.mkdirSync(path.dirname(outputPath), { recursive: true });
            fs.writeFileSync(outputPath, output);
            
            console.log(`✓ Saved: ${outputPath}`);
          }

          async function main() {
            const isInitialSync = process.env.IS_INITIAL_SYNC === 'true';
            const changedFilesPath = process.env.CHANGED_FILES;

            let filesToProcess = [];

            if (isInitialSync) {
              // NUR overview Ordner für ersten Test
              filesToProcess = glob.sync('docs/overview/**/*.md');
              console.log(`Initial sync (overview only): Found ${filesToProcess.length} files`);
            } else if (changedFilesPath && fs.existsSync(changedFilesPath)) {
              // Nur geänderte Dateien
              const changedFiles = fs.readFileSync(changedFilesPath, 'utf-8')
                .split('\n')
                .filter(f => f.endsWith('.md'));
              filesToProcess = changedFiles;
              console.log(`Processing ${filesToProcess.length} changed files`);
            }

            // Übersetze jede Datei
            for (const file of filesToProcess) {
              const outputPath = file.replace('docs/', 'i18n/de/docusaurus-plugin-content-docs/current/');
              
              try {
                await translateFile(file, outputPath);
              } catch (error) {
                console.error(`Failed to translate ${file}:`, error);
                process.exit(1);
              }
            }

            // Erstelle Summary
            const summary = {
              timestamp: new Date().toISOString(),
              filesProcessed: filesToProcess.length,
              files: filesToProcess
            };
            fs.writeFileSync('translation-summary.json', JSON.stringify(summary, null, 2));
            
            console.log('\n✓ Translation complete!');
          }

          main().catch(console.error);
          EOF

      # 8. Übersetzung ausführen
      - name: Run translation
        if: steps.changes.outputs.files_changed == 'true' || steps.changes.outputs.is_initial_sync == 'true'
        env:
          DEEPSEEK_API_KEY: ${{ secrets.DEEPSEEK_API_KEY }}
          IS_INITIAL_SYNC: ${{ steps.changes.outputs.is_initial_sync }}
          CHANGED_FILES: ${{ steps.changes.outputs.changed_files }}
        run: node translate.js

      # 9. Auf main zurücksetzen und nur i18n Änderungen vorbereiten
      - name: Prepare clean branch
        if: steps.changes.outputs.files_changed == 'true' || steps.changes.outputs.is_initial_sync == 'true'
        run: |
          # Sichere die übersetzten Dateien
          mkdir -p /tmp/translations
          cp -r i18n/de/ /tmp/translations/
          
          # Stash alle Änderungen
          git stash push -m "translations"
          
          # Zurück zu main
          git checkout main
          git pull origin main
          
          # Nur die übersetzten Dateien zurückholen
          cp -r /tmp/translations/de/ i18n/
          
          # Zeige was hinzugefügt wird
          git status
          git add i18n/de/
          git status

      # 10. PR im Fork erstellen (für deinen Review)
      # Die Action committed und pusht die Änderungen automatisch
      - name: Create Review PR
        if: steps.changes.outputs.files_changed == 'true' || steps.changes.outputs.is_initial_sync == 'true'
        uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          branch: translation-sync-${{ github.run_id }}
          base: main
          title: "[REVIEW NEEDED] Translation Sync - $(date +%Y-%m-%d)"
          body: |
            ## Übersetzungssync erstellt
            
            **Datum:** $(date +%Y-%m-%d)
            **Quelle:** qubic/docs
            
            ### Änderungen:
            Übersetzte Dateien im Overview-Ordner
            
            ### Nächste Schritte:
            1. [ ] Review der Übersetzungen durchführen
            2. [ ] Korrekturen direkt in diesen Branch commiten
            3. [ ] Nach Approval: Automatischer PR an qubic/docs wird erstellt
            
            **Wichtig:** Bitte innerhalb von 48h reviewn.
          commit-message: | 
            Translation sync: $(date +%Y-%m-%d)
            
            Automated translation of changed documentation files.
            Review required before creating upstream PR.
          delete-branch: false
          add-paths: |
            i18n/de/**

      # 12. Benachrichtigung senden (optional)
      - name: Send notification
        if: steps.changes.outputs.files_changed == 'true' || steps.changes.outputs.is_initial_sync == 'true'
        run: |
          echo "::notice title=Translation Ready::Review PR created. Please check the translations."
